/**
 * å®Œå…¨ä¸€æ°—é€šè²«ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
 * è¨˜äº‹ç”Ÿæˆ â†’ ç”»åƒç”Ÿæˆ â†’ Sanityçµ±åˆã®å…¨ãƒ—ãƒ­ã‚»ã‚¹ã‚’è‡ªå‹•åŒ–
 */

import { BackgroundProcessManager, BackgroundProcessConfig } from './background-process-manager';
import { ImageStatusManager } from './image-status-manager';
import { promises as fs } from 'fs';
import path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

export interface CompleteWorkflowConfig {
  sessionId: string;
  theme: string;
  articleType?: 'blog' | 'experience' | 'technical';
  generateImages?: boolean;
  imageCount?: number;
  autoPublish?: boolean;
}

export interface WorkflowResult {
  success: boolean;
  sessionId: string;
  phase: 'article' | 'images' | 'integration' | 'completed';
  article?: {
    filename: string;
    title: string;
    slug: string;
    wordCount: number;
  };
  images?: {
    generated: number;
    total: number;
    files: string[];
  };
  publication?: {
    sanityDocumentId?: string;
    publishedUrl?: string;
  };
  errors?: string[];
  nextSteps?: string[];
}

export class CompleteWorkflowManager {
  private static readonly PYTHON_PATH = '/Users/gotohiro/Documents/user/Products/stable-diffusion-local/venv310/bin/python';
  private static readonly ARTICLES_DIR = path.join(process.cwd(), 'articles');
  private static readonly UPLOAD_SCRIPT = path.join(process.cwd(), 'upload-from-json.js');

  /**
   * å®Œå…¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œ
   */
  static async executeCompleteWorkflow(config: CompleteWorkflowConfig): Promise<WorkflowResult> {
    const result: WorkflowResult = {
      success: false,
      sessionId: config.sessionId,
      phase: 'article',
      errors: [],
      nextSteps: []
    };

    try {
      console.log(`ğŸš€ å®Œå…¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼é–‹å§‹: ${config.sessionId}`);
      console.log(`ğŸ“ ãƒ†ãƒ¼ãƒ: ${config.theme}`);

      // Phase 1: è¨˜äº‹ç”Ÿæˆ
      console.log('\nğŸ“ Phase 1: è¨˜äº‹ç”Ÿæˆé–‹å§‹...');
      const articleResult = await this.generateArticle(config);
      
      if (!articleResult.success) {
        result.errors?.push(`è¨˜äº‹ç”Ÿæˆå¤±æ•—: ${articleResult.error}`);
        return result;
      }

      result.article = articleResult.article;
      console.log(`âœ… è¨˜äº‹ç”Ÿæˆå®Œäº†: ${articleResult.article?.filename}`);

      // Phase 2: ç”»åƒç”Ÿæˆï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
      if (config.generateImages) {
        console.log('\nğŸ¨ Phase 2: ç”»åƒç”Ÿæˆé–‹å§‹...');
        result.phase = 'images';

        const imageResult = await this.generateImages(config, articleResult.article!);
        
        if (!imageResult.success) {
          result.errors?.push(`ç”»åƒç”Ÿæˆå¤±æ•—: ${imageResult.error}`);
          result.nextSteps?.push('ç”»åƒç”Ÿæˆã‚’å¾Œã§å†å®Ÿè¡Œã—ã¦ãã ã•ã„');
        } else {
          result.images = imageResult.images;
          console.log(`âœ… ç”»åƒç”Ÿæˆå®Œäº†: ${imageResult.images?.generated}/${imageResult.images?.total}æš`);
        }
      }

      // Phase 3: Sanityçµ±åˆ
      if (config.autoPublish) {
        console.log('\nğŸ”„ Phase 3: Sanityçµ±åˆé–‹å§‹...');
        result.phase = 'integration';

        const publishResult = await this.publishToSanity(articleResult.article!);
        
        if (!publishResult.success) {
          result.errors?.push(`Sanityçµ±åˆå¤±æ•—: ${publishResult.error}`);
          result.nextSteps?.push('æ‰‹å‹•ã§Sanityã«æŠ•ç¨¿ã—ã¦ãã ã•ã„');
        } else {
          result.publication = publishResult.publication;
          console.log(`âœ… SanityæŠ•ç¨¿å®Œäº†: ${publishResult.publication?.publishedUrl}`);
        }
      }

      result.phase = 'completed';
      result.success = result.errors?.length === 0;

      if (result.success) {
        console.log('\nğŸ‰ å®Œå…¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼æˆåŠŸ!');
      } else {
        console.log('\nâš ï¸ éƒ¨åˆ†çš„æˆåŠŸï¼ˆä¸€éƒ¨ã‚¨ãƒ©ãƒ¼ã‚ã‚Šï¼‰');
      }

      return result;

    } catch (error) {
      console.error('ğŸš¨ ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œã‚¨ãƒ©ãƒ¼:', error);
      result.errors?.push(`å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: ${error instanceof Error ? error.message : 'Unknown error'}`);
      return result;
    }
  }

  /**
   * Phase 1: è¨˜äº‹ç”Ÿæˆ
   */
  private static async generateArticle(config: CompleteWorkflowConfig): Promise<{
    success: boolean;
    error?: string;
    article?: {
      filename: string;
      title: string;
      slug: string;
      wordCount: number;
    };
  }> {
    try {
      // ãƒã‚¹ã‚¿ãƒ¼ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”Ÿæˆ
      const masterPrompt = this.generateMasterPrompt(config.theme, config.articleType || 'blog');
      
      // è¨˜äº‹ç”Ÿæˆï¼ˆClaude Code Write toolç›¸å½“ã®å‡¦ç†ï¼‰
      const articleData = await this.generateArticleContent(masterPrompt);
      
      // JSONãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
      const filename = `${config.sessionId}.json`;
      const filepath = path.join(this.ARTICLES_DIR, filename);
      
      // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
      await fs.mkdir(this.ARTICLES_DIR, { recursive: true });
      
      // ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
      await fs.writeFile(filepath, JSON.stringify(articleData, null, 2), 'utf-8');
      
      console.log(`ğŸ’¾ è¨˜äº‹JSONä¿å­˜: ${filepath}`);
      
      return {
        success: true,
        article: {
          filename,
          title: articleData.title,
          slug: articleData.slug,
          wordCount: articleData.body.length
        }
      };

    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Article generation error'
      };
    }
  }

  /**
   * Phase 2: ç”»åƒç”Ÿæˆ
   */
  private static async generateImages(
    config: CompleteWorkflowConfig,
    article: { filename: string; title: string; slug: string; wordCount: number }
  ): Promise<{
    success: boolean;
    error?: string;
    images?: {
      generated: number;
      total: number;
      files: string[];
    };
  }> {
    try {
      const imageCount = config.imageCount || 4;
      const estimatedTimeMinutes = imageCount * 3.5;

      console.log(`ğŸ¨ ç”»åƒç”Ÿæˆé–‹å§‹: ${imageCount}æš (æ¨å®š${estimatedTimeMinutes}åˆ†)`);

      // ç”»åƒãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç”Ÿæˆ
      const imagePrompts = this.generateImagePrompts(article.title, config.theme, imageCount);

      // ã‚¹ãƒãƒ¼ãƒˆç”Ÿæˆï¼ˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå¯¾å¿œï¼‰
      const backgroundConfig: BackgroundProcessConfig = {
        sessionId: `${config.sessionId}-images`,
        totalImages: imageCount,
        imagePrompts
      };

      const smartResult = await BackgroundProcessManager.smartGeneration(backgroundConfig, 8);

      if (!smartResult.success) {
        return {
          success: false,
          error: smartResult.message
        };
      }

      if (smartResult.mode === 'background') {
        console.log('â° ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å‡¦ç†ã«åˆ‡ã‚Šæ›¿ã‚ã‚Šã¾ã—ãŸ');
        
        // ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å‡¦ç†ã®å ´åˆã¯çŠ¶æ…‹ç›£è¦–
        const monitorResult = await this.monitorBackgroundGeneration(smartResult.sessionId, 30);
        
        return {
          success: monitorResult.completed > 0,
          images: {
            generated: monitorResult.completed,
            total: imageCount,
            files: monitorResult.files
          }
        };
      } else {
        // ãƒ•ã‚©ã‚¢ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å‡¦ç†ã®å ´åˆã¯ç›´æ¥å®Ÿè¡Œ
        const directResult = await this.executeDirectImageGeneration(imagePrompts);
        
        return {
          success: directResult.success,
          error: directResult.error,
          images: directResult.images
        };
      }

    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Image generation error'
      };
    }
  }

  /**
   * Phase 3: Sanityçµ±åˆ
   */
  private static async publishToSanity(article: { filename: string; title: string; slug: string }): Promise<{
    success: boolean;
    error?: string;
    publication?: {
      sanityDocumentId?: string;
      publishedUrl?: string;
    };
  }> {
    try {
      console.log(`ğŸ”„ Sanityçµ±åˆé–‹å§‹: ${article.filename}`);

      // upload-from-json.js ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œ
      const command = `node ${this.UPLOAD_SCRIPT} articles/${article.filename}`;
      
      const { stdout, stderr } = await execAsync(command);
      
      if (stderr && !stderr.includes('warning')) {
        throw new Error(`Upload script error: ${stderr}`);
      }

      // Sanity Document IDæŠ½å‡ºï¼ˆstdout ã‹ã‚‰ï¼‰
      const documentIdMatch = stdout.match(/Document ID: ([a-zA-Z0-9]+)/);
      const documentId = documentIdMatch ? documentIdMatch[1] : undefined;

      // å…¬é–‹URLç”Ÿæˆ
      const publishedUrl = `https://hiro-logue.vercel.app/blog/${article.slug}`;

      console.log(`âœ… SanityæŠ•ç¨¿å®Œäº†: ${publishedUrl}`);

      return {
        success: true,
        publication: {
          sanityDocumentId: documentId,
          publishedUrl
        }
      };

    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Sanity integration error'
      };
    }
  }

  /**
   * ãƒã‚¹ã‚¿ãƒ¼ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç”Ÿæˆ
   */
  private static generateMasterPrompt(theme: string, articleType: string): string {
    return `HIRO_PERSONA.mdã¨HIRO_ARTICLE_STRUCTURE.mdã‚’å®Œå…¨ã«å‚ç…§ã—ã¦ã€ã€Œ${theme}ã€ã«ã¤ã„ã¦ã®${articleType === 'technical' ? 'æŠ€è¡“çš„ãª' : articleType === 'experience' ? 'ä½“é¨“é‡è¦–ã®' : ''}è¨˜äº‹ã‚’æ›¸ã„ã¦ãã ã•ã„ã€‚

ä»¥ä¸‹ã®JSONå½¢å¼ã§ã€articles/${Date.now()}.json ã«ä¿å­˜ã—ã¦ãã ã•ã„ï¼š

\`\`\`json
{
  "title": "è¨˜äº‹ã‚¿ã‚¤ãƒˆãƒ«",
  "body": "## ã¯ã˜ã‚ã«\\n\\nå€‹äººä½“é¨“ãƒ™ãƒ¼ã‚¹ã®å°å…¥...\\n\\n## ${theme}ã¨ã®å‡ºä¼šã„\\n\\nå…·ä½“çš„ãªä½“é¨“è«‡...\\n\\n## ãŠã‚ã‚Šã«\\n\\nèª­è€…ã¸ã®å•ã„ã‹ã‘...",
  "slug": "article-slug",
  "categories": ["é©åˆ‡ãªã‚«ãƒ†ã‚´ãƒª1", "ã‚«ãƒ†ã‚´ãƒª2"],
  "excerpt": "è¨˜äº‹ã®ç°¡æ½”ãªèª¬æ˜"
}
\`\`\`

é‡è¦ãªè¦ä»¶ï¼š
1. ãƒ’ãƒ­ã®ä¸€äººç§°ã§ã€å®Ÿä½“é¨“ãƒ™ãƒ¼ã‚¹ã®å†…å®¹
2. å®¶æ—ï¼ˆå¦»ãƒ»3äººã®å­ã©ã‚‚ãƒ»ãƒšãƒƒãƒˆï¼‰ã®è©±ã‚’è‡ªç„¶ã«ç¹”ã‚Šè¾¼ã‚€
3. æŠ€è¡“è€…è¦–ç‚¹ã§ã®å…·ä½“çš„ãªç™ºè¦‹ã‚„å­¦ã³
4. èª­è€…ã¸ã®å•ã„ã‹ã‘ã‚’è¤‡æ•°å›å«ã‚ã‚‹
5. 2000-2500æ–‡å­—ç¨‹åº¦ã®å……å®Ÿã—ãŸå†…å®¹
6. ç©ã‚„ã‹ã§ä¸å¯§ãªæ•¬èªã€æ¨æ¸¬è¡¨ç¾ã‚’å¤šç”¨
7. éŸ³å£°é…ä¿¡çš„è¡¨ç¾ã¯é¿ã‘ã€ãƒ–ãƒ­ã‚°é©åˆ‡ãªè¡¨ç¾ã‚’ä½¿ç”¨`;
  }

  /**
   * è¨˜äº‹ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆï¼ˆæ¨¡æ“¬å®Ÿè£…ï¼‰
   */
  private static async generateArticleContent(masterPrompt: string): Promise<any> {
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ Claude Code ã® Write tool ã‚’ä½¿ç”¨
    // ã“ã“ã§ã¯æ¨¡æ“¬çš„ãªãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™
    const timestamp = Date.now();
    const slug = `generated-article-${timestamp}`;
    
    return {
      title: `AIæŠ€è¡“ã¨æ—¥å¸¸ç”Ÿæ´»ã®èåˆã«ã¤ã„ã¦è€ƒãˆã¦ã¿ã¾ã—ãŸ`,
      body: `## ã¯ã˜ã‚ã«\n\nã“ã‚“ã«ã¡ã¯ã€ãƒ’ãƒ­ã§ã™ã€‚\n\næœ€è¿‘ã€ç§ãŸã¡ã®æ—¥å¸¸ç”Ÿæ´»ã«AIæŠ€è¡“ãŒè‡ªç„¶ã«æº¶ã‘è¾¼ã‚“ã§ãã¦ã„ã‚‹ã®ã‚’å®Ÿæ„Ÿã—ã¦ã„ã¾ã™ã€‚\n\n## AIæŠ€è¡“ã¨ã®æ—¥ã€…ã®å‡ºä¼šã„\n\nå…ˆæ—¥ã€æˆ‘ãŒå®¶ã®ä¸­å­¦ç”Ÿã®å­ã©ã‚‚ãŒå®¿é¡Œã§AIã‚’ä½¿ã£ã¦èª¿ã¹ç‰©ã‚’ã—ã¦ã„ã‚‹ã®ã‚’è¦‹ã¦ã€æ™‚ä»£ã®å¤‰åŒ–ã‚’æ„Ÿã˜ã¾ã—ãŸã€‚\n\nå¦»ã¨ã‚‚ã€Œç§ãŸã¡ãŒå­ã©ã‚‚ã®é ƒã¨ã¯å…¨ç„¶é•ã†ã‚ˆã­ã€ã¨è©±ã—ã¦ã„ãŸã‚“ã§ã™ã­ã€‚\n\n## æŠ€è¡“ã¨äººé–“ã‚‰ã—ã•ã®ãƒãƒ©ãƒ³ã‚¹\n\nãƒ—ãƒ­ã‚°ãƒ©ãƒãƒ¼ã¨ã—ã¦ã€AIã®é€²æ­©ã¯æœ¬å½“ã«ç´ æ™´ã‚‰ã—ã„ã¨æ€ã„ã¾ã™ã€‚\n\nã§ã‚‚åŒæ™‚ã«ã€äººé–“ã‚‰ã—ã•ã‚„æ¸©ã‹ã¿ã‚‚å¤§åˆ‡ã«ã—ãŸã„ãªã¨æ„Ÿã˜ã¦ã„ã¾ã™ã€‚\n\n## ãŠã‚ã‚Šã«\n\nçš†ã•ã‚“ã‚‚ã€AIã¨äººé–“ã‚‰ã—ã•ã®ãƒãƒ©ãƒ³ã‚¹ã«ã¤ã„ã¦ã€ã©ã®ã‚ˆã†ã«æ„Ÿã˜ã¦ã„ã‚‰ã£ã—ã‚ƒã„ã¾ã™ã‹ï¼Ÿ\n\nã‚‚ã—ã‚ˆã‚ã—ã‘ã‚Œã°ã€ã‚³ãƒ¡ãƒ³ãƒˆã§æ•™ãˆã¦ãã ã•ã„ã­ã€‚`,
      slug: slug,
      categories: ["AI", "æŠ€è¡“", "æ—¥å¸¸ç”Ÿæ´»"],
      excerpt: "AIæŠ€è¡“ãŒæ—¥å¸¸ç”Ÿæ´»ã«æº¶ã‘è¾¼ã‚€ç¾ä»£ã«ãŠã„ã¦ã€æŠ€è¡“ã¨äººé–“ã‚‰ã—ã•ã®ãƒãƒ©ãƒ³ã‚¹ã«ã¤ã„ã¦è€ƒå¯Ÿã—ã¾ã—ãŸã€‚"
    };
  }

  /**
   * ç”»åƒãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç”Ÿæˆ
   */
  private static generateImagePrompts(title: string, theme: string, count: number): any[] {
    const basePrompt = `A peaceful cozy room representing ${theme}, modern technology harmoniously integrated with natural elements, empty comfortable seating area, japanese minimalist interior design, warm atmosphere, professional photography`;
    
    const negativePrompt = `person, people, human, man, woman, face, realistic human features, portrait, character, figure, text, watermark, blurry, lowres, bad anatomy`;

    const styles = [
      { name: 'warm_minimal', style: 'warm lighting, cozy atmosphere, japanese minimalist', description: 'æ¸©ã‹ã¿ã®ã‚ã‚‹ãƒŸãƒ‹ãƒãƒ«' },
      { name: 'modern_tech', style: 'modern technology focus, clean lines, contemporary', description: 'ãƒ¢ãƒ€ãƒ³ãƒ†ã‚¯ãƒãƒ­ã‚¸ãƒ¼' },
      { name: 'natural_organic', style: 'natural materials, organic shapes, plant-focused', description: 'è‡ªç„¶ç´ æé‡è¦–' },
      { name: 'soft_bokeh', style: 'soft focus, bokeh effect, dreamy atmosphere', description: 'ã‚½ãƒ•ãƒˆãƒ•ã‚©ãƒ¼ã‚«ã‚¹' }
    ];

    return Array.from({ length: count }, (_, i) => {
      const style = styles[i % styles.length];
      return {
        index: i,
        position: i === 0 ? 'header' : `section${i}`,
        prompt: `${basePrompt}, ${style.style}`,
        negative_prompt: negativePrompt,
        style: style.name,
        description: style.description,
        parameters: {
          width: 1600,
          height: 896,
          num_inference_steps: 25,
          guidance_scale: 7.5
        }
      };
    });
  }

  /**
   * ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ç”Ÿæˆç›£è¦–
   */
  private static async monitorBackgroundGeneration(sessionId: string, timeoutMinutes: number): Promise<{
    completed: number;
    total: number;
    files: string[];
  }> {
    const startTime = Date.now();
    const timeoutMs = timeoutMinutes * 60 * 1000;

    while (Date.now() - startTime < timeoutMs) {
      try {
        const status = await BackgroundProcessManager.getProcessStatus();
        const generationStatus = await BackgroundProcessManager.getGenerationStatus();

        if (!status.isRunning && generationStatus?.status === 'completed') {
          // å®Œäº†
          return {
            completed: generationStatus.completed || 0,
            total: generationStatus.total || 0,
            files: (generationStatus.variations || [])
              .filter((v: any) => v.status === 'success')
              .map((v: any) => v.filename)
          };
        }

        if (status.isRunning) {
          console.log(`ğŸ”„ ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ç”Ÿæˆé€²è¡Œä¸­: ${status.progress?.completed}/${status.progress?.total}`);
        }

        // 5ç§’å¾…æ©Ÿ
        await new Promise(resolve => setTimeout(resolve, 5000));

      } catch (error) {
        console.error('ç›£è¦–ã‚¨ãƒ©ãƒ¼:', error);
        break;
      }
    }

    // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã¾ãŸã¯ã‚¨ãƒ©ãƒ¼
    const finalStatus = await BackgroundProcessManager.getGenerationStatus();
    return {
      completed: finalStatus?.completed || 0,
      total: finalStatus?.total || 0,
      files: (finalStatus?.variations || [])
        .filter((v: any) => v.status === 'success')
        .map((v: any) => v.filename)
    };
  }

  /**
   * ç›´æ¥ç”»åƒç”Ÿæˆï¼ˆãƒ•ã‚©ã‚¢ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ï¼‰
   */
  private static async executeDirectImageGeneration(prompts: any[]): Promise<{
    success: boolean;
    error?: string;
    images?: {
      generated: number;
      total: number;
      files: string[];
    };
  }> {
    try {
      // Python ã‚¹ã‚¯ãƒªãƒ—ãƒˆç›´æ¥å®Ÿè¡Œ
      const command = `${this.PYTHON_PATH} test-1x4-variations.py`;
      
      const { stdout, stderr } = await execAsync(command, { timeout: 600000 }); // 10åˆ†ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
      
      if (stderr && !stderr.includes('warning')) {
        throw new Error(`Image generation error: ${stderr}`);
      }

      // ç”Ÿæˆãƒ•ã‚¡ã‚¤ãƒ«ç¢ºèª
      const outputDir = 'public/images/blog/test-1x4-variations';
      const files = await fs.readdir(outputDir).catch(() => []);
      const imageFiles = files.filter(f => f.endsWith('.png'));

      return {
        success: true,
        images: {
          generated: imageFiles.length,
          total: prompts.length,
          files: imageFiles
        }
      };

    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Direct generation error'
      };
    }
  }

  /**
   * ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼çŠ¶æ…‹å–å¾—
   */
  static async getWorkflowStatus(sessionId: string): Promise<WorkflowResult | null> {
    try {
      // ã‚»ãƒƒã‚·ãƒ§ãƒ³æƒ…å ±ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã¿
      const statusFile = path.join(process.cwd(), `workflow-${sessionId}.json`);
      const statusContent = await fs.readFile(statusFile, 'utf-8');
      return JSON.parse(statusContent);
    } catch (error) {
      return null;
    }
  }

  /**
   * ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼çŠ¶æ…‹ä¿å­˜
   */
  static async saveWorkflowStatus(result: WorkflowResult): Promise<void> {
    try {
      const statusFile = path.join(process.cwd(), `workflow-${result.sessionId}.json`);
      await fs.writeFile(statusFile, JSON.stringify(result, null, 2), 'utf-8');
    } catch (error) {
      console.error('ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼çŠ¶æ…‹ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
    }
  }
}