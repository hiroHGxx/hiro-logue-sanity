/**
 * ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ—ãƒ­ã‚»ã‚¹ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
 * Claude Codeã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆåˆ¶ç´„ã‚’å›é¿ã™ã‚‹ãŸã‚ã€é•·æ™‚é–“ã‚¿ã‚¹ã‚¯ã‚’
 * ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ—ãƒ­ã‚»ã‚¹ã§å®Ÿè¡Œã—ã€çŠ¶æ…‹ã‚’ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã™ã‚‹
 */

import { exec, spawn } from 'child_process';
import { promises as fs } from 'fs';
import path from 'path';

export interface BackgroundProcessConfig {
  sessionId: string;
  totalImages: number;
  imagePrompts?: ImagePromptConfig[];
  outputDir?: string;
}

export interface ImagePromptConfig {
  position: string;
  prompt: string;
  negativePrompt: string;
  style: string;
  description: string;
  parameters: {
    width: number;
    height: number;
    num_inference_steps: number;
    guidance_scale: number;
  };
}

export interface BackgroundProcessStatus {
  isRunning: boolean;
  pid?: number;
  sessionId?: string;
  startedAt?: string;
  progress?: {
    completed: number;
    total: number;
    failed: number;
  };
}

export class BackgroundProcessManager {
  private static readonly PYTHON_PATH = '/Users/gotohiro/Documents/user/Products/stable-diffusion-local/venv310/bin/python';
  private static readonly SCRIPT_PATH = path.join(process.cwd(), 'scripts', 'background-image-generator.py');
  private static readonly PID_FILE = path.join(process.cwd(), 'background-generator.pid');
  private static readonly LOG_FILE = path.join(process.cwd(), 'background-generation.log');

  /**
   * ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ—ãƒ­ã‚»ã‚¹ã®çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯
   */
  static async getProcessStatus(): Promise<BackgroundProcessStatus> {
    try {
      // PIDãƒ•ã‚¡ã‚¤ãƒ«å­˜åœ¨ç¢ºèª
      const pidExists = await fs.access(this.PID_FILE).then(() => true).catch(() => false);
      
      if (!pidExists) {
        return { isRunning: false };
      }

      // PIDèª­ã¿è¾¼ã¿
      const pidContent = await fs.readFile(this.PID_FILE, 'utf-8');
      const pid = parseInt(pidContent.trim());

      // ãƒ—ãƒ­ã‚»ã‚¹å­˜åœ¨ç¢ºèª
      const isRunning = await this.isProcessRunning(pid);
      
      if (!isRunning) {
        // PIDãƒ•ã‚¡ã‚¤ãƒ«å‰Šé™¤
        await fs.unlink(this.PID_FILE).catch(() => {});
        return { isRunning: false };
      }

      // çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰è©³ç´°æƒ…å ±å–å¾—
      const statusData = await this.getGenerationStatus();
      
      return {
        isRunning: true,
        pid,
        sessionId: statusData?.session_id,
        startedAt: statusData?.startedAt,
        progress: {
          completed: statusData?.completed || 0,
          total: statusData?.total || 0,
          failed: statusData?.failed || 0
        }
      };

    } catch (error) {
      console.error('ãƒ—ãƒ­ã‚»ã‚¹çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼:', error);
      return { isRunning: false };
    }
  }

  /**
   * ãƒ—ãƒ­ã‚»ã‚¹å®Ÿè¡Œç¢ºèª
   */
  private static async isProcessRunning(pid: number): Promise<boolean> {
    return new Promise((resolve) => {
      exec(`ps -p ${pid}`, (error) => {
        resolve(!error);
      });
    });
  }

  /**
   * ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ç”»åƒç”Ÿæˆé–‹å§‹
   */
  static async startBackgroundGeneration(config: BackgroundProcessConfig): Promise<{
    success: boolean;
    message: string;
    sessionId?: string;
  }> {
    try {
      // æ—¢å­˜ãƒ—ãƒ­ã‚»ã‚¹ãƒã‚§ãƒƒã‚¯
      const status = await this.getProcessStatus();
      if (status.isRunning) {
        return {
          success: false,
          message: `æ—¢ã«ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ—ãƒ­ã‚»ã‚¹ãŒå®Ÿè¡Œä¸­ã§ã™ (PID: ${status.pid})`
        };
      }

      console.log(`ğŸš€ ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ç”»åƒç”Ÿæˆé–‹å§‹: ${config.sessionId}`);

      // Python ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œ
      const args = [
        this.SCRIPT_PATH,
        '--session-id', config.sessionId,
        '--total', config.totalImages.toString(),
        '--daemon'
      ];

      const child = spawn(this.PYTHON_PATH, args, {
        detached: true,
        stdio: ['ignore', 'ignore', 'ignore']
      });

      child.unref(); // è¦ªãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰åˆ‡ã‚Šé›¢ã—

      // çŸ­æ™‚é–“å¾…æ©Ÿã—ã¦ãƒ—ãƒ­ã‚»ã‚¹é–‹å§‹ç¢ºèª
      await new Promise(resolve => setTimeout(resolve, 2000));

      const finalStatus = await this.getProcessStatus();
      
      return {
        success: finalStatus.isRunning,
        message: finalStatus.isRunning 
          ? `ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ç”Ÿæˆé–‹å§‹ã—ã¾ã—ãŸ (PID: ${finalStatus.pid})`
          : 'ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ—ãƒ­ã‚»ã‚¹ã®é–‹å§‹ã«å¤±æ•—ã—ã¾ã—ãŸ',
        sessionId: config.sessionId
      };

    } catch (error) {
      console.error('ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ç”Ÿæˆé–‹å§‹ã‚¨ãƒ©ãƒ¼:', error);
      return {
        success: false,
        message: `ã‚¨ãƒ©ãƒ¼: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  /**
   * ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ—ãƒ­ã‚»ã‚¹åœæ­¢
   */
  static async stopBackgroundGeneration(): Promise<{
    success: boolean;
    message: string;
  }> {
    try {
      const status = await this.getProcessStatus();
      
      if (!status.isRunning || !status.pid) {
        return {
          success: true,
          message: 'å®Ÿè¡Œä¸­ã®ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ—ãƒ­ã‚»ã‚¹ã¯ã‚ã‚Šã¾ã›ã‚“'
        };
      }

      // ãƒ—ãƒ­ã‚»ã‚¹çµ‚äº†
      process.kill(status.pid, 'SIGTERM');
      
      // PIDãƒ•ã‚¡ã‚¤ãƒ«å‰Šé™¤
      await fs.unlink(this.PID_FILE).catch(() => {});

      return {
        success: true,
        message: `ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ—ãƒ­ã‚»ã‚¹ã‚’åœæ­¢ã—ã¾ã—ãŸ (PID: ${status.pid})`
      };

    } catch (error) {
      console.error('ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ—ãƒ­ã‚»ã‚¹åœæ­¢ã‚¨ãƒ©ãƒ¼:', error);
      return {
        success: false,
        message: `åœæ­¢ã‚¨ãƒ©ãƒ¼: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  /**
   * ç”ŸæˆçŠ¶æ…‹å–å¾—ï¼ˆçŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ï¼‰
   */
  static async getGenerationStatus(): Promise<any> {
    try {
      const statusFile = path.join(process.cwd(), 'image-generation-status.json');
      const statusContent = await fs.readFile(statusFile, 'utf-8');
      return JSON.parse(statusContent);
    } catch (error) {
      return null;
    }
  }

  /**
   * ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
   */
  static async getProcessLogs(tailLines: number = 50): Promise<string[]> {
    try {
      const logContent = await fs.readFile(this.LOG_FILE, 'utf-8');
      const lines = logContent.split('\n').filter(line => line.trim());
      return lines.slice(-tailLines);
    } catch (error) {
      return [];
    }
  }

  /**
   * ãƒ—ãƒ­ã‚»ã‚¹ç›£è¦–ï¼ˆå®šæœŸçš„ãªçŠ¶æ…‹ç¢ºèªï¼‰
   */
  static async monitorProcess(
    onUpdate: (status: BackgroundProcessStatus) => void,
    intervalMs: number = 5000
  ): Promise<() => void> {
    
    const checkStatus = async () => {
      const status = await this.getProcessStatus();
      onUpdate(status);
    };

    // åˆå›ãƒã‚§ãƒƒã‚¯
    await checkStatus();

    // å®šæœŸãƒã‚§ãƒƒã‚¯é–‹å§‹
    const interval = setInterval(checkStatus, intervalMs);

    // åœæ­¢é–¢æ•°ã‚’è¿”ã™
    return () => {
      clearInterval(interval);
    };
  }

  /**
   * ã‚»ãƒƒã‚·ãƒ§ãƒ³ç¶™ç¶šï¼ˆä¸­æ–­ã‹ã‚‰å†é–‹ï¼‰
   */
  static async resumeSession(sessionId: string): Promise<{
    success: boolean;
    message: string;
  }> {
    try {
      console.log(`ğŸ”„ ã‚»ãƒƒã‚·ãƒ§ãƒ³ç¶™ç¶š: ${sessionId}`);

      const args = [
        this.SCRIPT_PATH,
        '--resume', sessionId
      ];

      const child = spawn(this.PYTHON_PATH, args, {
        detached: true,
        stdio: ['ignore', 'ignore', 'ignore']
      });

      child.unref();

      return {
        success: true,
        message: `ã‚»ãƒƒã‚·ãƒ§ãƒ³ç¶™ç¶šã‚’é–‹å§‹ã—ã¾ã—ãŸ: ${sessionId}`
      };

    } catch (error) {
      return {
        success: false,
        message: `ã‚»ãƒƒã‚·ãƒ§ãƒ³ç¶™ç¶šã‚¨ãƒ©ãƒ¼: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  /**
   * Claude Codeã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå¯¾å¿œã®ã‚¹ãƒãƒ¼ãƒˆå®Ÿè¡Œ
   * ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒè¿‘ã„å ´åˆã¯è‡ªå‹•çš„ã«ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å‡¦ç†ã«åˆ‡ã‚Šæ›¿ãˆ
   */
  static async smartGeneration(
    config: BackgroundProcessConfig,
    maxExecutionMinutes: number = 8
  ): Promise<{
    mode: 'foreground' | 'background';
    success: boolean;
    message: string;
    sessionId: string;
  }> {
    
    const estimatedTimeMinutes = config.totalImages * 3.5; // 1æšã‚ãŸã‚Šç´„3.5åˆ†
    
    if (estimatedTimeMinutes > maxExecutionMinutes) {
      // ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å‡¦ç†ãŒå¿…è¦
      const result = await this.startBackgroundGeneration(config);
      return {
        mode: 'background',
        success: result.success,
        message: `æ¨å®šå®Ÿè¡Œæ™‚é–“${estimatedTimeMinutes}åˆ†ã®ãŸã‚ã€ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å‡¦ç†ã«åˆ‡ã‚Šæ›¿ãˆã¾ã—ãŸã€‚${result.message}`,
        sessionId: config.sessionId
      };
    } else {
      // ãƒ•ã‚©ã‚¢ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å‡¦ç†ã§å®Ÿè¡Œå¯èƒ½
      return {
        mode: 'foreground',
        success: true,
        message: `æ¨å®šå®Ÿè¡Œæ™‚é–“${estimatedTimeMinutes}åˆ†ã®ãŸã‚ã€é€šå¸¸å‡¦ç†ã§å®Ÿè¡Œã—ã¾ã™`,
        sessionId: config.sessionId
      };
    }
  }
}