/**
 * Phase C: „Éè„Ç§„Éñ„É™„ÉÉ„ÉâÁîªÂÉèÁîüÊàê„ÉØ„Éº„Ç´„Éº
 * Phase AÊñπÂºèÔºàÁõ¥Êé•PythonÂÆüË°åÔºâ„Çí„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÂåñ
 * + Sanity CMSÁµ±Âêà
 */

const { spawn } = require('child_process');
const path = require('path');
const fs = require('fs/promises');

// TypeScript logger.ts„Çí‰ΩøÁî®„Åô„Çã„Åü„ÇÅ„ÅÆESM import
let logger;
(async () => {
  try {
    const loggerModule = await import('../lib/logger.js');
    logger = loggerModule;
  } catch (error) {
    console.warn('‚ö†Ô∏è Logger module not available, using console logging');
    // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÁî®„ÅÆ„ÉÄ„Éü„Éºlogger
    logger = {
      logToContentFlow: async (entry) => {
        const emoji = entry.level === 'ERROR' ? '‚ùå' : 
                     entry.action === 'start' ? 'üöÄ' :
                     entry.action === 'complete' ? '‚úÖ' : 'üîÑ';
        console.log(`${emoji} [${entry.source}] ${entry.message}`);
      },
      logError: async (sessionId, phase, source, error) => {
        console.error(`‚ùå [${source}] Error in ${phase}:`, error.message);
      }
    };
  }
})();

class HybridImageWorker {
  constructor() {
    this.isRunning = false;
    this.pollInterval = 5000; // 5ÁßíÈñìÈöî„Åß„Éù„Éº„É™„É≥„Ç∞
    this.pythonEnvPath = '/Users/gotohiro/Documents/user/Products/stable-diffusion-local/venv310/bin/python';
    this.scriptPath = './scripts/auto-sd-generator.py';
    this.flagsDir = './data/jobs/flags';
    this.configsDir = './data/jobs/configs';
    this.completedDir = './data/jobs/completed';
  }

  async start() {
    if (this.isRunning) {
      console.log('‚ö†Ô∏è Hybrid Worker already running');
      return;
    }

    this.isRunning = true;
    console.log('üöÄ Phase C Hybrid Image Worker started');
    console.log('üéØ Monitoring flag directory:', this.flagsDir);

    // „Éá„Ç£„É¨„ÇØ„Éà„É™ÂàùÊúüÂåñ
    await this.initializeDirectories();
    
    // „Éù„Éº„É™„É≥„Ç∞„É´„Éº„ÉóÈñãÂßã
    this.startPolling();
  }

  stop() {
    this.isRunning = false;
    console.log('üõë Hybrid Image Worker stopped');
  }

  async initializeDirectories() {
    const dirs = [this.flagsDir, this.configsDir, this.completedDir];
    
    for (const dir of dirs) {
      try {
        await fs.mkdir(dir, { recursive: true });
      } catch (error) {
        console.error(`Failed to create directory ${dir}:`, error);
      }
    }
  }

  startPolling() {
    const poll = async () => {
      if (!this.isRunning) return;

      try {
        await this.processPendingJobs();
      } catch (error) {
        console.error('‚ùå Error in polling loop:', error);
      }

      if (this.isRunning) {
        setTimeout(poll, this.pollInterval);
      }
    };

    poll();
  }

  async processPendingJobs() {
    try {
      // „Éï„É©„Ç∞„Éï„Ç°„Ç§„É´‰∏ÄË¶ßÂèñÂæó
      const files = await fs.readdir(this.flagsDir);
      const flagFiles = files.filter(file => file.endsWith('.flag'));

      if (flagFiles.length === 0) {
        return; // Âá¶ÁêÜÂæÖ„Å°„Ç∏„Éß„Éñ„Å™„Åó
      }

      console.log(`üìã Found ${flagFiles.length} pending jobs`);

      // ÊúÄ„ÇÇÂè§„ÅÑ„Ç∏„Éß„Éñ„ÇíÂá¶ÁêÜ
      flagFiles.sort();
      const flagFile = flagFiles[0];
      const flagPath = path.join(this.flagsDir, flagFile);

      await this.processJob(flagPath);

    } catch (error) {
      console.error('‚ùå Error processing pending jobs:', error);
    }
  }

  async processJob(flagPath) {
    let sessionId = 'unknown';
    
    try {
      // „Éï„É©„Ç∞„Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„Åø
      const flagData = await fs.readFile(flagPath, 'utf-8');
      const job = JSON.parse(flagData);
      sessionId = job.sessionId || `job_${job.articleId}`;

      console.log(`üé® Processing job: ${job.articleId}`);
      console.log(`üìù Config: ${job.configPath}`);

      if (logger.logToContentFlow) {
        await logger.logToContentFlow({
          level: 'INFO',
          source: 'hybrid-worker',
          sessionId,
          phase: 'image-generation',
          action: 'start',
          message: `ÁîªÂÉèÁîüÊàê„Ç∏„Éß„ÉñÈñãÂßã: ${job.articleId}`,
          data: { articleId: job.articleId, configPath: job.configPath }
        });
      }

      // Âá∫Âäõ„Éá„Ç£„É¨„ÇØ„Éà„É™Ê∫ñÂÇô
      const outputDir = path.join('public/images/blog/auto-generated', job.articleId);
      await fs.mkdir(outputDir, { recursive: true });

      // Phase AÊñπÂºè„ÅßPythonÂÆüË°å
      const startTime = Date.now();
      const generatedFiles = await this.executePhaseAStyle(job.configPath, outputDir, sessionId);
      const generationDuration = (Date.now() - startTime) / 1000;

      if (logger.logToContentFlow) {
        await logger.logToContentFlow({
          level: 'INFO',
          source: 'hybrid-worker',
          sessionId,
          phase: 'image-generation',
          action: 'complete',
          message: `ÁîªÂÉèÁîüÊàêÂÆå‰∫Ü: ${generatedFiles.length}Êûö`,
          data: { 
            articleId: job.articleId, 
            imageCount: generatedFiles.length,
            duration: generationDuration
          }
        });
      }

      // Sanity CMSÁµ±Âêà
      await this.integrateSanityImages(job.articleId, outputDir, sessionId);

      // ÂÆå‰∫ÜË®òÈå≤‰ΩúÊàê
      await this.recordCompletion(job, generatedFiles, outputDir);

      // „Éï„É©„Ç∞„Éï„Ç°„Ç§„É´ÂâäÈô§
      await fs.unlink(flagPath);

      console.log(`‚úÖ Job completed successfully: ${job.articleId}`);
      console.log(`üìÇ Generated ${generatedFiles.length} images in: ${outputDir}`);

    } catch (error) {
      console.error(`‚ùå Job failed:`, error);
      
      if (logger.logError) {
        await logger.logError(sessionId, 'image-generation', 'hybrid-worker', error);
      }
      
      // „Ç®„É©„ÉºÊôÇ„ÅØ„Éï„É©„Ç∞„Éï„Ç°„Ç§„É´„Çí‰øùÊåÅÔºàÊâãÂãïÁ¢∫Ë™çÁî®Ôºâ
      try {
        const flagData = await fs.readFile(flagPath, 'utf-8');
        const job = JSON.parse(flagData);
        job.status = 'failed';
        job.error = error.message;
        job.failedAt = new Date().toISOString();
        
        await fs.writeFile(flagPath, JSON.stringify(job, null, 2));
      } catch (writeError) {
        console.error('Failed to update flag file with error:', writeError);
      }
    }
  }

  async executePhaseAStyle(configPath, outputDir, sessionId = 'unknown') {
    return new Promise((resolve, reject) => {
      console.log(`üêç Phase A Style Execution:`);
      console.log(`   Config: ${configPath}`);
      console.log(`   Output: ${outputDir}`);

      const pythonProcess = spawn(this.pythonEnvPath, [
        this.scriptPath,
        '--config', configPath,
        '--output', outputDir,
        '--variations', '1'
      ], {
        stdio: ['pipe', 'pipe', 'pipe'],
        env: { ...process.env }
      });

      let stdout = '';
      let stderr = '';

      pythonProcess.stdout.on('data', (data) => {
        const output = data.toString().trim();
        stdout += output;
        console.log(`[Python]: ${output}`);
      });

      pythonProcess.stderr.on('data', (data) => {
        const output = data.toString().trim();
        stderr += output;
        console.error(`[Python Error]: ${output}`);
      });

      pythonProcess.on('close', async (code) => {
        if (code === 0) {
          try {
            // ÁîüÊàê„Éï„Ç°„Ç§„É´‰∏ÄË¶ßÂèñÂæó
            const files = await fs.readdir(outputDir);
            const imageFiles = files.filter(file => 
              file.endsWith('.png') || file.endsWith('.jpg') || file.endsWith('.jpeg')
            );
            const fullPaths = imageFiles.map(file => path.join(outputDir, file));
            
            console.log(`‚úÖ Phase A execution completed. Generated ${imageFiles.length} images.`);
            resolve(fullPaths);
          } catch (error) {
            reject(new Error(`Failed to read generated files: ${error}`));
          }
        } else {
          reject(new Error(`Python script failed with code ${code}. Stderr: ${stderr}`));
        }
      });

      pythonProcess.on('error', (error) => {
        reject(new Error(`Failed to start Python process: ${error.message}`));
      });

      // „Çø„Ç§„É†„Ç¢„Ç¶„ÉàË®≠ÂÆö (30ÂàÜ)
      const timeout = setTimeout(() => {
        pythonProcess.kill('SIGTERM');
        reject(new Error('Python script execution timed out (30 minutes)'));
      }, 30 * 60 * 1000);

      pythonProcess.on('close', () => {
        clearTimeout(timeout);
      });
    });
  }

  async integrateSanityImages(articleId, outputDir, sessionId = 'unknown') {
    try {
      console.log(`üîÑ Starting Sanity integration for article: ${articleId}`);
      
      if (logger.logToContentFlow) {
        await logger.logToContentFlow({
          level: 'INFO',
          source: 'hybrid-worker',
          sessionId,
          phase: 'sanity-integration',
          action: 'start',
          message: `SanityÁµ±ÂêàÈñãÂßã: ${articleId}`,
          data: { articleId, outputDir }
        });
      }
      
      const integrationProcess = spawn('node', [
        path.join(__dirname, 'sanity-integration.js'),
        articleId,
        outputDir,
        sessionId  // „Çª„ÉÉ„Ç∑„Éß„É≥ID„ÇíÊ∏°„Åô
      ], {
        stdio: 'inherit',
        env: { ...process.env }
      });

      return new Promise((resolve, reject) => {
        integrationProcess.on('close', async (code) => {
          if (code === 0) {
            console.log(`‚úÖ Sanity integration completed for article: ${articleId}`);
            
            if (logger.logToContentFlow) {
              await logger.logToContentFlow({
                level: 'INFO',
                source: 'hybrid-worker',
                sessionId,
                phase: 'sanity-integration',
                action: 'complete',
                message: `SanityÁµ±ÂêàÂÆå‰∫Ü: ${articleId}`,
                data: { articleId }
              });
            }
            
            resolve();
          } else {
            console.error(`‚ùå Sanity integration failed with code: ${code}`);
            
            if (logger.logError) {
              await logger.logError(sessionId, 'sanity-integration', 'hybrid-worker', 
                new Error(`Sanity integration failed with code ${code}`));
            }
            
            reject(new Error(`Sanity integration failed with code ${code}`));
          }
        });

        integrationProcess.on('error', async (error) => {
          console.error(`‚ùå Failed to start Sanity integration:`, error);
          
          if (logger.logError) {
            await logger.logError(sessionId, 'sanity-integration', 'hybrid-worker', error);
          }
          
          reject(error);
        });
      });

    } catch (error) {
      console.error(`‚ùå Sanity integration error:`, error);
      
      if (logger.logError) {
        await logger.logError(sessionId, 'sanity-integration', 'hybrid-worker', error);
      }
      
      throw error;
    }
  }

  async recordCompletion(job, generatedFiles, outputDir) {
    const completion = {
      articleId: job.articleId,
      configPath: job.configPath,
      outputDir,
      generatedFiles,
      imageCount: generatedFiles.length,
      startedAt: job.createdAt,
      completedAt: new Date().toISOString(),
      duration: Date.now() - new Date(job.createdAt).getTime(),
      status: 'completed'
    };

    const completionPath = path.join(this.completedDir, `${job.articleId}.json`);
    await fs.writeFile(completionPath, JSON.stringify(completion, null, 2));

    console.log(`üìÑ Completion record saved: ${completionPath}`);
  }

  async getStats() {
    try {
      const [pendingFiles, completedFiles] = await Promise.all([
        fs.readdir(this.flagsDir).then(files => files.filter(f => f.endsWith('.flag'))),
        fs.readdir(this.completedDir).then(files => files.filter(f => f.endsWith('.json')))
      ]);

      return {
        isRunning: this.isRunning,
        pending: pendingFiles.length,
        completed: completedFiles.length,
        lastCheck: new Date().toISOString()
      };
    } catch (error) {
      return {
        isRunning: this.isRunning,
        error: error.message
      };
    }
  }
}

// „É°„Ç§„É≥ÂÆüË°å
console.log('üöÄ Starting Phase C Hybrid Image Worker...');
console.log('üéØ Phase AÊñπÂºèÔºàÁõ¥Êé•PythonÂÆüË°åÔºâ+ „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÂá¶ÁêÜ');

const worker = new HybridImageWorker();

// Graceful shutdown
process.on('SIGINT', () => {
  console.log('üõë Received SIGINT, shutting down gracefully...');
  worker.stop();
  process.exit(0);
});

process.on('SIGTERM', () => {
  console.log('üõë Received SIGTERM, shutting down gracefully...');
  worker.stop();
  process.exit(0);
});

// „ÉØ„Éº„Ç´„ÉºÈñãÂßã
worker.start().catch(error => {
  console.error('‚ùå Failed to start hybrid worker:', error);
  process.exit(1);
});

// Áµ±Ë®àÊÉÖÂ†±ÂÆöÊúüË°®Á§∫
setInterval(async () => {
  if (worker.isRunning) {
    const stats = await worker.getStats();
    console.log(`üìä Stats: ${stats.pending} pending, ${stats.completed} completed`);
  }
}, 30000); // 30ÁßíÈñìÈöî